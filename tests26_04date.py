# -*- coding: utf-8 -*-
"""Tests26.04Date.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t3cW7ZIY3dX7XojqpPoINmrAT_mdWT-9

Для тестирования можно использовать библиотеку pytest (как в примере: https://youtu.be/1HtEPEn4-LY)
"""

all_tests = [
' за сегодня ' ,
' за вчера ' ,
' за позавчера ' ,
' за последний день ' ,
' за последнюю неделю ' ,
' за последний месяц ' ,
' за последний квартал ' ,
' за последнее полугодие ' ,
' за последний год ' ,
' за последние два дня ' ,
' за последние три недели ' ,
' за последние четыре месяца ' ,
' за последние два квартал ' ,
' за последние три года ' ,
' за прошлый день ' ,
' за прошлую неделю ' ,
' за прошлый месяц ' ,
' за прошлый квартал ' ,
' за прошлое полугодие ' ,
' за прошлый год ' ,
' за два прошлых дня ' ,
' за две прошлых недели ' ,
' за три прошлых месяца ' ,
' за четыре прошлых года ' ,
' за предыдущий день ' ,
' за предыдущую неделю ' ,
' за предыдущий месяц ' ,
' за предыдущий квартал ' ,
' за предыдущее полугодие ' ,
' за предыдущий год ' ,
' за два предыдущих дня ' ,
' за две предыдущих недели ' ,
' за три предыдущих месяца ' ,
' за четыре предыдущих года ' ,
' за день ' ,
' за один день ' ,
' за три дня ' ,
' за десять дней ' ,
' за двадцать дней ' ,
' за 1 день ' ,
' за 3 дня ' ,
' за 10 дней ' ,
' за неделю ' ,
' за одну неделю ' ,
' за три недели ' ,
' за десять недель ' ,
' за 1 неделю ' ,
' за 3 недели ' ,
' за 10 недель ' ,
' за месяц ' ,
' за один месяц ' ,
' за три месяца ' ,
' за десять месяцев ' ,
' за 1 месяц ' ,
' за 2 месяца ' ,
' за 3 месяца ' ,
' за 10 месяцев ' ,
' за квартал ' ,
' за один квартал ' ,
' за три квартала ' ,
' за 1 квартал ' ,
' за 3 месяца ' ,
' за полугодие ' ,
' за два полугодия ' ,
' за 2 полугодя ' ,
' за год ' ,
' за один год ' ,
' за три года ' ,
' за десять лет ' ,
' за 1 год ' ,
' за 3 года ' ,
' три дня назад ' ,
' две недели назад ' ,
' два месяца назад ' ,
' полгода назад ' ,
' год назад ' ,
' на прошлой неделе ' ,
' за январь ' ,
' за март 2012го ' ,
' за апрель 2008 ' ,
' за август 2019 года ' ,
' за 2011 год ' ,
' за 2012й ' ,
' за 2021 ' ,
' за второй квартал ' ,
' за июнь прошлого года ' ,
' за август позапрошлого года ' ,
' за первый квартал текущего года ' ,
' за третий квартал позапрошлого года ' ,
' за 2й квартал прошлого года ' ,
' за третий квартал предыдущего года ' ,
' за март месяц прошедшего года ' ,
' за февраль прошлого года ' ,
' за второе полугодие прошлого года ' ,
' за 2 неделю прошлого месяца ' ,
' за первую неделю сентября прошлого года ' ,
' за первый месяц 2020 года ' ,
' за второй день третьей недели второго квартала ' ,
' за 4 квартал 2020 года ' ,
' за три недели первого квартала 2019 года ' ,
' за вторую неделю сентября 2020 года ' ,
' с апреля 2010 года ' ,
' после апреля 2010 года ' ,
' за апрель 2010 года ' ,
' с мая по июнь 2020 года ' ,
' с февраля по апрель позапрошлого года ' ,
' до июня текущего года ' ,
' с января 2011 года по март 2012го ' ,
' с июня по декабрь ' ,
' с 2001 по 2012 гг ' ,
' с первого до десятого апреля 2019 года ' ,
' с августа по октябрь ' ,
' в апреле ' ,
' в марте 2012 года ' ,
' в апреле прошлого года ' ,
' в мае позапрошлого года ' ,
' во втором квартале ' ,
' в прошлом месяце ' ,
' в прошлом году ' ,
' в позапрошлом году ' ,
' в 2018 году ' ,
' в 2005-2010 годах ' ,
' в 2012-2013 гг ' ,
' с 2012 по 2013 ' ,
' c 01.10 по 01.12 ' ,
' с 01.02.2003 по 21.12.2012 ' ,
' с 01.02 по 21.12 ' ,
' с первого октября по первое декабря 2012 года ' ,
' с двадцать второго числа апреля месяца ' ,
' с первого полугодия прошлого года ' ,
' с третьего квартала текущего года ' ,
' со второй по четвертую неделю первого квартала ' ,
' с первого по третий квартал прошлого года ' ,
' с 1 по 3 неделю сентября 2013 года ' ,
' со второго квартала 2019 по третий квартал 2020 ' ,
' с января по май 2019 и с первого по третий квартал прошлого года ' ,
' отчет Павлова на портале за прошлую неделю ' ,
' отчет Иванов вики xlsx за прошлый месяц ' ,
' Иванов справка о доходах за прошлый год ' ,
' справка Сидорова pdf три дня назад ' ,
' квитанция от Ивана Петровича на прошлой неделе pdf ' ,
' квартальный отчет Светланы docx за прошлый квартал ' 
]

!pip install natasha

list(TOKENIZER('за'))# NUMR

lines = [
'за второй квартал предыдущего года ',
'за вторую неделю прошлого месяца ',
'за первую неделю сентября прошлого года ',
'за второй день третьей недели второго квартала ',
'за первый месяц 2020 года ',
'за три недели первого квартала 2019 года ',
'за 4 квартал 2020 года ',
'за три дня ',
'за прошлую неделю ',
'за предыдущий месяц ',
'с апреля 2010 года ',
'после апреля 2010 года ',
'за апрель 2010 года ',
'с мая по июнь 2020 года',
'с февраля по апрель позапрошлого года ',
'до июня текущего года ',
'за последние три года',
'в 2018 году ',
'с 01.10 по 01.12 ',
'со второй по четвертую неделю первого квартала ',
'со второго квартала  2019 по третий квартал 2020 ',
'с января по май 2019 и с первого по третий квартал прошлого года '
]

Quarter = fact(
        'Quarter',
        ['quarter_ordinal','quarter_cardinal','quarter_start_ordinal','quarter_end_ordinal'],
    )

class ExtractDate(object):

  def __init__(self):
        self.year = []
        self.quater = []
        self.month = []
        self.week = []
        self.day = [] 

        self.week_ordinal = []
        self.week_cardinal = []
        self.week_modifier = []
        self.week_start_ordinal= []
        self.week_end_ordinal= []

        self.quarter_ordinal= []
        self.quarter_cardinal= []
        self.quarter_start_ordinal= []
        self.quarter_end_ordinal= []

        self.month_modifier= []
        self.month_ordinal= []
        self.month_cardinal= []

        self.half_year = []
        self.count = []

        self.year_modifier= []
        self.year_cardinal= []
        self.year_start_modifier= []
        self.year_end_modifier= []

        self.date= []

        self.day_ordinal= []
        self.day_cardinal= []
        self.day_modifier = []

        self.start_date= []
        self.end_date= []
        

  def get_date(self):
      if self.year != None:
            print("Год: ", match.fact.year)
      if self.quater != None:
            print("Квартал: ", match.fact.quater)
      if self.mouth != None:
            print("Месяц: ", match.fact.mouth)
      if self.week != None:
            print("Неделя: ", match.fact.week)
      if self.day != None:
            print("День: ", match.fact.day)  

def skip_none(arr):
  #print("arr", arr)
  out = ''
  for el in arr:
    #print(el)
    if el != None:
      out = el
  return out    


def viz( date ,line, matches, count_date): 
  result = []
  #print(matches)
  for match in matches:
    #print("________________________")
    #print("Дата: ", line)
    #print(match.fact)
    #for chank in match.fact:
    #  if chank != None:
    #    print(chank)
    #display(match.tree.as_dot)
    date.quarter_cardinal.append(match.fact.quarter_cardinal)
    date.quarter_ordinal.append(match.fact.quarter_ordinal)
    date.year_modifier.append(match.fact.year_modifier)
    date.year_cardinal.append(match.fact.year_cardinal)
    date.week_modifier.append(match.fact.week_modifier)
    date.week_ordinal.append(match.fact.week_ordinal)
    date.week_cardinal.append(match.fact.week_cardinal)
    date.month_ordinal.append(match.fact.month_ordinal)
    date.month_modifier.append(match.fact.month_modifier)
    date.day_cardinal.append(match.fact.day_cardinal)
    date.day_ordinal.append(match.fact.day_ordinal)
    date.start_date.append(match.fact.start_date)
    date.end_date.append(match.fact.end_date)
    date.day_modifier.append(match.fact.day_modifier)
    date.half_year.append(match.fact.half_year)
    date.count.append(match.fact.count)
    date.date.append(match.fact.date)
    #date.day.append(match.fact.day)
  if len(str(skip_none(date.quarter_cardinal))) > 0:  
    print("quarter_cardinal: ", skip_none(date.quarter_cardinal))
  if len(str(skip_none(date.quarter_ordinal))) > 0:  
    print("quarter_ordinal: ", skip_none(date.quarter_ordinal))
  if len(str(skip_none(date.year_modifier))) > 0:  
    print("year_modifier: ", skip_none(date.year_modifier))
  if len(str(skip_none(date.year_cardinal))) > 0:  
    print("year_cardinal: ", skip_none(date.year_cardinal))
  if len(str(skip_none(date.date))) > 0:  
    print("date: ", skip_none(date.date))
  if len(str(skip_none(date.week_ordinal))) > 0:  
    print("week_ordinal: ", skip_none(date.week_ordinal))
  if len(str(skip_none(date.week_cardinal))) > 0:  
    print("week_cardinal: ", skip_none(date.week_cardinal))  
  if len(str(skip_none(date.week_modifier))) > 0:  
    print("week_modifier: ", skip_none(date.week_modifier)) 
  if len(str(skip_none(date.month_ordinal))) > 0:  
    print("month_ordinal: ", skip_none(date.month_ordinal))
  if len(str(skip_none(date.month_modifier))) > 0:  
    print("month_modifier: ", skip_none(date.month_modifier))       
  if len(str(skip_none(date.day_cardinal))) > 0:  
    print("day_cardinal: ", skip_none(date.day_cardinal))
  if len(str(skip_none(date.day_ordinal))) > 0:  
    print("day_ordinal: ", skip_none(date.day_ordinal))   
  if len(str(skip_none(date.start_date))) > 0:  
    print("start_date: ", skip_none(date.start_date))
  if len(str(skip_none(date.end_date))) > 0:  
    print("end_date: ", skip_none(date.end_date))  
  if len(str(skip_none(date.day_modifier))) > 0:  
    print("day_modifier: ", skip_none(date.day_modifier)) 
  if len(str(skip_none(date.half_year))) > 0:  
    print("half_year: ", skip_none(date.half_year))   
  if len(str(skip_none(date.count))) > 0:  
    print("count: ", skip_none(date.count))              
  #print("Квартал: ", skip_none(date.quater))
  #print("Месяц: ", skip_none(date.month))
  #print("Неделя: ", skip_none(date.week))
  #print("День: ", skip_none(date.day))

from yargy.parser import prepare_trees
from yargy import Parser, or_, rule
from yargy import (
    rule,
    and_, or_, not_
)
from yargy.interpretation import fact
from yargy.predicates import (
    eq, gte, lte, length_eq,
    dictionary, normalized,
)
from yargy.predicates import (
    eq, in_, dictionary,
    type, gram
)

Date = fact(
    'Date',
    #['year', 'quater', 'month','week',  'day']
    ['week_ordinal','week_cardinal','week_modifier', 'week_start_ordinal', 'week_end_ordinal',

'quarter_ordinal','quarter_cardinal','quarter_start_ordinal','quarter_end_ordinal',

'month_modifier','month_ordinal','month_cardinal',

'year_modifier','year_cardinal','year_start_modifier','year_end_modifier',

'half_year','count', 

'day_ordinal', 'day_cardinal', 'day_modifier',

'date', 'date_month', 'start_date', 'end_date']
)


class Date(Date):
    @property
    def obj(self):
        from natasha import obj
        return obj.Date(#self.year ,self.quater, self.month , self.week,self.day ,
                        self.week_ordinal ,self.week_cardinal ,self.week_modifier,self.week_start_ordinal,self.week_end_ordinal,
        self.quarter_ordinal,self.quarter_cardinal,self.quarter_start_ordinal,self.quarter_end_ordinal,self.month_modifier,
        self.month_ordinal,self.month_cardinal,self.date_month, self.year_modifier,self.year_cardinal,self.year_start_modifier,
        self.half_year,self.count,  
        self.year_end_modifier,self.date,self.day_ordinal, self.day_cardinal, self.day_modifier, self.start_date,self.end_date
        )

INT = type('INT')
NOUN = gram('NOUN')
ADJF = gram('ADJF')
PRTF = gram('PRTF')
GENT = gram('gent')
NUMR = gram('NUMR')
DOT = eq('.')

MONTHS = {
    'январь': 1,
    'февраль': 2,
    'март': 3,
    'апрель': 4,
    'май': 5,
    'июнь': 6,
    'июль': 7,
    'август': 8,
    'сентябрь': 9,
    'октябрь': 10,
    'ноябрь': 11,
    'декабрь': 12,
    'текущий': 0, 
}
MODIFIERS = {
    'текущий': 0,
    'прошлый': -1, 
    'позапрошлый': -2, 
    'позавчерашний':-2,
    'прошедшее': -1,
    'последний': -0.5, 
    'прошлый' : -1,
    'предыдущий':-1, 
    'вчерашний': -1,
    'истекший': -1,
    'прошлое': -1,
    'прошлого' : -1 , 
    'три': 3,
    'один':1,
    '2019':2019
}

FROM_STR_TO_INT = {
    'апрель':4,
    'за':1,
    'три': 3, 
    'второй': 2,
    'первый': 1,
    'третий':3,
    '4':4,
    '1':1,
    '3':3,
    '2':2,
    'две':2,
    '2й':2,
    '2ю':2,
    '10':10,
    'один': 1,
    'прошлый': -1,
    'четвёртый':4 ,
    'четыре': 4,
    'два': 2,
    'десять':10,
    'последний': -0.5,
    'предыдущий': -1,
    'двадцать':20,
    'сегодня': 0, 
    'вчера': -1, 
    'позавчера':-2,
    'последнее': -0.5,
    'прошлое': -1,
    'второе':2,
    'назад': -1
}


YEAR_WORD = or_(
    rule('г', eq('.').optional()),
    rule(normalized('год')), 
    rule('года')
)

YEAR_STR = or_(
    ADJF
).interpretation(
    Date.year_modifier.normalized().custom(MODIFIERS.__getitem__)
)
YEAR_INT = or_(
    
    NUMR
).interpretation(
    Date.year_cardinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)
YEAR = and_(
    gte(1000),
    lte(2100)
).interpretation(
    Date.year_cardinal.custom(int)
)

YEAR_SHORT = and_(
    length_eq(2),
    gte(0),
    lte(99)
).interpretation(
    Date.year_cardinal.custom(lambda _: 1900 + int(_))
)



QUATER_WORD = or_(
    rule(normalized('квартал')), 
    rule('квартала')
)

QUATER_INT = or_(
    INT, 
    NUMR
).interpretation(
    Date.quarter_cardinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)

QUATER_ADJF= or_(
    ADJF
).interpretation(
    Date.quarter_ordinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)


ADJF_INT_NUMR= or_(
    #ADJF,
    INT, 
    NUMR
)

MODIFIER = or_(
    eq(normalized('прошлую')),
    eq(normalized('прошлый')), 
    eq(normalized('предыдущий')), 
    eq(normalized('прошлого')), 
    eq(normalized('прошлое')),
    eq(normalized('последний')), 
    eq('последнее')
)

MONTH_MODIFIER = or_(
    eq(normalized('прошлую')),
    eq('прошлый'), 
    eq('предыдущий'), 
    eq('прошлого'), 
    eq('прошлое'),
    eq('последний')
).interpretation(
    Date.month_modifier.normalized().custom(MODIFIERS.__getitem__)
)

MONTH_NAME = dictionary(MONTHS).interpretation(
    Date.month_ordinal.normalized().custom(MONTHS.__getitem__)
)

MONTH = and_(
    gte(1),
    lte(12)
).interpretation(
    Date.month_ordinal.custom(int)
)

MONTH_WORD = or_(
    rule(normalized('месяц'))
)

MONTH_STR = not_(
    or_(
    eq(normalized('прошлую')),
    eq('прошлый'), 
    eq('предыдущий'), 
    eq('прошлого'), 
    eq('прошлое'),
    eq('последний'), 
    eq('март'),
    eq(normalized('апрель')))

).interpretation(
    Date.month_ordinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)


WEEK_WORD = or_(
    rule(normalized('неделя'))
)

WEEK_MODIFIER = or_(
    eq('прошлую'),
    eq('прошлый'), 
    eq('прошлое'), 
    eq('последний')
).interpretation(
    Date.week_modifier.normalized().custom(MODIFIERS.__getitem__)
)

WEEK_ORIG= not_(
     
    or_(
    eq('три'),     
    eq('прошлую'),
    eq('прошлый'), 
    eq('прошлое'),
    eq('последний'))
).interpretation(
    Date.week_ordinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)
WEEK_CARD = or_(
    eq('три')
).interpretation(
    Date.week_cardinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)

DAY = and_(
    gte(1),
    lte(31)
).interpretation(
    Date.day_ordinal.custom(int)
)

DAY_STR = not_(
    or_(
    eq(normalized('прошлую')),
    eq('прошлый'), 
    eq('предыдущий'), 
    eq('прошлого'), 
    eq('прошлое'), 
    eq('последний'))
).interpretation(
    Date.day_ordinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)
DAY_INT = or_(
    NUMR
).interpretation(
    Date.day_cardinal.normalized().custom(FROM_STR_TO_INT.__getitem__)
)
DAY_WORD  = or_ (
    rule(normalized('день'))
)
PERIOD_START = or_(
    
)

ALL_WORD = not_(
    eq('fkn')
)

DAY_MODIFIER = or_(
    eq('прошлую'),
    eq('прошлый'), 
    eq('прошлое'), 
    eq('последний'), 
    eq("предыдущий")
).interpretation(
    Date.day_modifier.normalized().custom(MODIFIERS.__getitem__)
)
multipleDATE = or_(
    rule(
        eq('с'),
        ADJF.optional().interpretation(Date.start_date.custom(str)),
        NOUN.optional().interpretation(Date.start_date.custom(str)),
        
        eq('по'),
          
        ADJF.optional().interpretation(Date.end_date.custom(str)),
        NOUN.optional().interpretation(Date.end_date.custom(str)),       
    ), 
    #DATE
)

DATE = or_(
    rule(
        or_(eq('сегодня'),eq("вчера") ,eq('позавчера')).interpretation(Date.day_ordinal.custom(FROM_STR_TO_INT.__getitem__))
        
    ),
    rule(
        ADJF_INT_NUMR.optional().interpretation(Date.count),
        DAY_MODIFIER, 
        DAY_WORD        
    ),
    rule(
        ADJF_INT_NUMR.optional(), 
        DAY_WORD        
    ),

    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        DAY_STR, 
        DAY_WORD        
    ),
    rule(
        WEEK_CARD, 
        WEEK_WORD        
    ),
    
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        WEEK_ORIG, 
        WEEK_WORD        
    ),
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        WEEK_MODIFIER, 
        WEEK_WORD        
    ),
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        MONTH_MODIFIER, 
        MONTH_WORD
    ),
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        MONTH_STR, 
        MONTH_WORD
    ),
    rule(
        
        MONTH_NAME , 
        MONTH_WORD.optional() 
    ),
    rule(
        
        QUATER_INT, 
        QUATER_WORD 
    ),
    
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        QUATER_ADJF, 
        QUATER_WORD 
    ),
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        YEAR_STR,
        YEAR_WORD
    ),
    rule(
        ALL_WORD.interpretation(Date.half_year.normalized().custom(FROM_STR_TO_INT.__getitem__)),
        or_(eq('полугодие'),eq('полугодия'))
         
        
    ),
    rule(
        
        YEAR_WORD,
        or_(INT, NUMR).interpretation(Date.year_modifier) ,
        eq('назад')
    ),  
    rule(
        YEAR_INT,
        YEAR_WORD
    ), 
    rule(
        or_(INT, NUMR).optional().interpretation(Date.count.custom(FROM_STR_TO_INT.__getitem__)),
        YEAR,#.optional(), 
        YEAR_WORD 
    ),
    rule(
        YEAR_SHORT, 
        YEAR_WORD 
    ), 
    rule(
        #INT.optional().interpretation(Date.year_modifier),
        YEAR_WORD,
        eq('назад').optional().interpretation(Date.year_cardinal.custom(FROM_STR_TO_INT.__getitem__)) 
    ),
    rule(
        YEAR
    )
).interpretation(
    Date
)

from natasha import (
    MorphVocab,
    DatesExtractor
)
from IPython.display import display
from yargy.parser import prepare_trees
import re
from yargy.tokenizer import MorphTokenizer
from yargy import (
    Parser,
    or_, rule
)
from yargy.predicates import (
    eq, in_, dictionary,
    type, gram
)

INT = type('INT')
NOUN = gram('NOUN')
ADJF = gram('ADJF')
PRTF = gram('PRTF')
GENT = gram('gent')
NUMR = gram('NUMR')
DOT = eq('.')

TOKENIZER = MorphTokenizer()
morph_vocab = MorphVocab()
parser = Parser(DATE)
#dates_extractor = DATE(morph_vocab)

line = ' за квартал '
split_on_date = re.split(r'с |по | до ', line )
for split in split_on_date:
  date = ExtractDate()
  matches = parser.extract(split)
  viz(date , split, matches, len(split_on_date))

import re

str_num = 1
for line in all_tests:
  print(str_num, "Исходный текст: ", line)
  str_num = str_num + 1
  split_on_date = re.split(r'с |по | до ', line )
  for split in split_on_date:
    date = ExtractDate()
    matches = parser.extract(split)
    #print("______________________")
    #print(split)
    #try:
    viz(date , split, matches, len(split_on_date))
    #except:
    #  print("Can't parse")
  print("========================")

"""# Измеряем качество"""

tests = [
' за сегодня ' ,
' за вчера ' ,
' за позавчера ' ,
' за последний день ' ,
' за последнюю неделю ' ,
' за последний месяц ' ,
' за последний квартал ' ,
' за последнее полугодие ']

class ExtractDate(object):

  def __init__(self):
        self.year = []
        self.quater = []
        self.month = []
        self.week = []
        self.day = [] 

        self.week_ordinal = []
        self.week_cardinal = []
        self.week_modifier = []
        self.week_start_ordinal= []
        self.week_end_ordinal= []

        self.quarter_ordinal= []
        self.quarter_cardinal= []
        self.quarter_start_ordinal= []
        self.quarter_end_ordinal= []

        self.month_modifier= []
        self.month_ordinal= []
        self.month_cardinal= []

        self.half_year = []
        self.count = []

        self.year_modifier= []
        self.year_cardinal= []
        self.year_start_modifier= []
        self.year_end_modifier= []

        self.date= []

        self.day_ordinal= []
        self.day_cardinal= []
        self.day_modifier = []

        self.start_date= []
        self.end_date= []
        

  def get_date(self):
      if self.year != None:
            print("Год: ", match.fact.year)
      if self.quater != None:
            print("Квартал: ", match.fact.quater)
      if self.mouth != None:
            print("Месяц: ", match.fact.mouth)
      if self.week != None:
            print("Неделя: ", match.fact.week)
      if self.day != None:
            print("День: ", match.fact.day)  

def skip_none(arr):
  #print("arr", arr)
  out = ''
  for el in arr:
    #print(el)
    if el != None:
      out = el
  return out    


def viz(str_num,  date ,line, matches, count_date): 
  #result = []
  #str_num_day
  #print(matches)
  for match in matches:
    #print("________________________")
    #print("Дата: ", line)
    #print(match.fact)
    #for chank in match.fact:
    #  if chank != None:
    #    print(chank)
    #display(match.tree.as_dot)
    date.quarter_cardinal.append(match.fact.quarter_cardinal)
    date.quarter_ordinal.append(match.fact.quarter_ordinal)
    date.year_modifier.append(match.fact.year_modifier)
    date.year_cardinal.append(match.fact.year_cardinal)
    date.week_modifier.append(match.fact.week_modifier)
    date.week_ordinal.append(match.fact.week_ordinal)
    date.week_cardinal.append(match.fact.week_cardinal)
    date.month_ordinal.append(match.fact.month_ordinal)
    date.month_modifier.append(match.fact.month_modifier)
    date.day_cardinal.append(match.fact.day_cardinal)
    date.day_ordinal.append(match.fact.day_ordinal)
    date.start_date.append(match.fact.start_date)
    date.end_date.append(match.fact.end_date)
    date.day_modifier.append(match.fact.day_modifier)
    date.half_year.append(match.fact.half_year)
    date.count.append(match.fact.count)
    date.date.append(match.fact.date)
    #date.day.append(match.fact.day)
  if len(str(skip_none(date.quarter_cardinal))) > 0:  
    print("quarter_cardinal: ", skip_none(date.quarter_cardinal))
  if len(str(skip_none(date.quarter_ordinal))) > 0:  
    print("quarter_ordinal: ", skip_none(date.quarter_ordinal))
  if len(str(skip_none(date.year_modifier))) > 0:  
    print("year_modifier: ", skip_none(date.year_modifier))
  if len(str(skip_none(date.year_cardinal))) > 0:  
    print("year_cardinal: ", skip_none(date.year_cardinal))
  if len(str(skip_none(date.date))) > 0:  
    print("date: ", skip_none(date.date))
  if len(str(skip_none(date.week_ordinal))) > 0:  
    print("week_ordinal: ", skip_none(date.week_ordinal))
  if len(str(skip_none(date.week_cardinal))) > 0:  
    print("week_cardinal: ", skip_none(date.week_cardinal))  
  if len(str(skip_none(date.week_modifier))) > 0:  
    print("week_modifier: ", skip_none(date.week_modifier)) 
  if len(str(skip_none(date.month_ordinal))) > 0:  
    print("month_ordinal: ", skip_none(date.month_ordinal))
  if len(str(skip_none(date.month_modifier))) > 0:  
    print("month_modifier: ", skip_none(date.month_modifier))       
  if len(str(skip_none(date.day_cardinal))) > 0:  
    print("day_cardinal: ", skip_none(date.day_cardinal))
  if len(str(skip_none(date.day_ordinal))) > 0:  
    print("day_ordinal: ", skip_none(date.day_ordinal))  
    pred_day_ordinal.append(skip_none(date.day_ordinal)) 
    num_day_ordinal.append(str_num)
  if len(str(skip_none(date.start_date))) > 0:  
    print("start_date: ", skip_none(date.start_date))
  if len(str(skip_none(date.end_date))) > 0:  
    print("end_date: ", skip_none(date.end_date))  
  if len(str(skip_none(date.day_modifier))) > 0:  
    print("day_modifier: ", skip_none(date.day_modifier)) 
  if len(str(skip_none(date.half_year))) > 0:  
    print("half_year: ", skip_none(date.half_year))   
  if len(str(skip_none(date.count))) > 0:  
    print("count: ", skip_none(date.count))              
  #print("Квартал: ", skip_none(date.quater))
  #print("Месяц: ", skip_none(date.month))
  #print("Неделя: ", skip_none(date.week))
  #print("День: ", skip_none(date.day))

import re
num_day_ordinal = []
str_num = 0
pred_day_ordinal = []
for line in tests:
  print(str_num, "Исходный текст: ", line)
  str_num = str_num + 1
  split_on_date = re.split(r'с |по | до ', line )
  for split in split_on_date:
    date = ExtractDate()
    matches = parser.extract(split)
    #print("______________________")
    #print(split)
    #try:
    viz(str_num, date , split, matches, len(split_on_date))
    #except:
    #  print("Can't parse")
  print("========================")

# accuracy - делим количество правильных ответов на все

def accuracy(true, pred):
  all_case = len(pred)
  try_case = 0
  for i in range(all_case):
    if pred[i] == true[i]:
      try_case = try_case + 1
  return try_case/all_case

from sklearn.metrics import classification_report

#Для кажого класса (каждой сущьности) получаем качество 

print("Номера тестов ", num_day_ordinal)
#true_day_ordinal = [0, 1, 2, 2, 2]

print("Предсказанные day_ordinal", pred_day_ordinal)
true_day_ordinal = [0, -1, -2]
print("Правильные day_ordinal", true_day_ordinal)
target_names = ['day_ordinal']
print(accuracy(true_day_ordinal, pred_day_ordinal))